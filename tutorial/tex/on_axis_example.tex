\section{On-axis example}

\textbf{Note: It is recommended that you the ``swap'' example of Section~\ref{sec:swap_example} before this one.}

\subsection{Observations}

For this example, the data provided are a small subset of the data obtained on $\beta$ Pictoris in September 2018. There are 5 files, contained in the ``betapic'' directory. Let's start by loading the files, and printing some interesting infos. We will automatically apply the same OPD dispersion and metrology corrections as the pipeline does, using \verb|corrDisp = "drs"| and \verb|corrMet = "drs"|.
\lstinputlisting[linerange={1-14}]{../python/onaxis_example.py}

\noindent{}This will give you the following output, in which you may recognize the observing strategy used for an on-axis target, where the fiber moves back-and-forth from the star to the planet:
\begin{verbatim}
At mjd=58383.3408, fiber was at RA=0.35 mas, DEC=0.63 mas, flux was 102581.03 ADU/s
At mjd=58383.3415, fiber was at RA=72.00 mas, DEC=123.00 mas, flux was 2438.96 ADU/s
At mjd=58383.3454, fiber was at RA=0.35 mas, DEC=0.63 mas, flux was 98523.78 ADU/s
\end{verbatim}

\noindent{}In this case, only 3 files are provided, but the complete sequence on $\beta$ Pic contained many more. The small offset for the on-star position is due to the acquisition sequence, in which it is necessary to set a small ofset to ensure the correct alignment of the beamsplitter in the instrument. Let's separate the two types of observations:
\lstinputlisting[linerange={16-18}]{../python/onaxis_example.py}

\subsection{Phase referencing the visibilities}

The first step in the data reduction process is to calculate the phase-reference. In the swap example of Section~\ref{sec:swap_example}, the phase-reference was calculated by adding the two swap positions. In this on-axis example, the strategy to calculate the phase-reference is even simpler. Since the star is on the axis, the star itself is the reference is RA/DEC. Thus, its astrophyscial phase is zero, and the phase of its visibility (corrected for all the usual effects) is directly given by:
\begin{equation*}
\phi(u, v) = \phi_\mathrm{ref}(u, v)
\end{equation*}

Thus, in an on-axis observation, the phase reference can be extracted simply by calculating the mean of the star observations. What's even better is that since the star is at zero OPD, there is no need for shifting the visibilities before calculating the average. The visibility reference is simply:
\lstinputlisting[linerange={20-21}]{../python/onaxis_example.py}

\noindent{}From which we can extract a reference for the amplitude and a reference for the phase:
\lstinputlisting[linerange={23-25}]{../python/onaxis_example.py}

\noindent{}The on-planet visibility is phase-referenced by:
\lstinputlisting[linerange={27-28}]{../python/onaxis_example.py}


\subsection{Subtracting the star}

Now that the visibility is phase-referenced, let's plot it to see what it looks like:
\lstinputlisting[linerange={30-34}]{../python/onaxis_example.py}

\noindent{}So where are the fringes? We actually can't see them, because the visibilities are dominated by the star. So we first need to remove the stellar component. To do that, you can fit a a low-order polynomial in wavelength, multiplied by the reference amplitude, to take into account the chromaticity of this ``speckel noise''.  Since there can also be some small fluctuations in the phase, its best to do the fitting with complex coefficients. The fit is done baseline per baseline, dit per dit:
\lstinputlisting[linerange={36-47}]{../python/onaxis_example.py}

\noindent{}To overplot the result to the previous figure:
\lstinputlisting[linerange={49-50}]{../python/onaxis_example.py}

\noindent{}Now we can subtract this stellar component to the visibilities, and plot the residuals in a new figure:
\lstinputlisting[linerange={52-55}]{../python/onaxis_example.py}

\noindent{Wow! Nice fringes!}


\subsection{Extracting the astrometry}

Once the visibilities are properly corrected, and the stellar component removed, fitting for the astrometry can be done in the same way as for the swap example:
\lstinputlisting[linerange={58-92}]{../python/onaxis_example.py}

\noindent{}The last lines are here to overplot the result of the best fit for the first dit, and to display the $\chi^2$ map.

Although this fit already gives a decent result, it is suboptimal in many different ways. First off, the amplitude of the fringes of the planet is not taken into account. To refine the astrometry, a model of the planet visibility amplitude can be obtained by using a model contrast spectrum (from a model of the planet and a model of the star), multiplied by the \verb|ampRef| term calculated from the star exposures. Then, the stellar subtraction should not be done independantly of the planet fringes fit, but a complete model, which include both elements, should be used. And finally, the error terms should be properly taken into account. The exoGravity pipeline includes all these improvements, as well as some other minor things.

